var documenterSearchIndex = {"docs": [

{
    "location": "index.html#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": ""
},

{
    "location": "index.html#LARLIB.jl-1",
    "page": "Home",
    "title": "LARLIB.jl",
    "category": "section",
    "text": ""
},

{
    "location": "index.html#Dependencies-1",
    "page": "Home",
    "title": "Dependencies",
    "category": "section",
    "text": "LARLIB.jl has several Julia dependencies:NearestNeighbors\nDataStructures\nIntervalTrees\nTRIANGLE"
},

{
    "location": "index.html#LARLIB.bbox_contains",
    "page": "Home",
    "title": "LARLIB.bbox_contains",
    "category": "function",
    "text": "bbox_contains(container, contained)\n\nCheck if the axis aligned bounding box container contains contained.\n\nEach input box must be passed as the couple of Points standing on the opposite corners of the box.\n\n\n\n"
},

{
    "location": "index.html#Docstrings-conventions-1",
    "page": "Home",
    "title": "Docstrings conventions",
    "category": "section",
    "text": "Bold is used to point out theory concepts. For example, look at the  \"2-skeletons\" word in the docstring of LARLIB.skel_merge:LARLIB.skel_merge(V1::LARLIB.Points, EV1::LARLIB.Cells, V2::LARLIB.Points, EV2::LARLIB.Cells)Monospace is used for everything code related. Look this time at \"container\", \"contained\" and \"Points\" in the docstring of LARLIB.bbox_contains:LARLIB.bbox_containsnote: Note\nIn Julia REPL the monospace text is the one colored differently. In a terminal you will see something like:   (Image: Julia REPL monospace exaple)"
},

{
    "location": "lar.html#",
    "page": "LAR",
    "title": "LAR",
    "category": "page",
    "text": ""
},

{
    "location": "lar.html#LAR-1",
    "page": "LAR",
    "title": "LAR",
    "category": "section",
    "text": "LAR is a general representation scheme for geometric and topological modeling~\\cite{Dicarlo:2014:TNL:2543138.2543294}.  The domain of the scheme is provided by cellular complexes while its codomain is a set of sparse matrices. The main advantages of the scheme are:It is extremely effective to easily represent general non-manifold solids.  For example, the memory representation of a d=3 cellular complex using LAR consists in only two binary sparse matrices for the topology and a bi-dimensional array for the geometry.\nComputation and analysis of cellular complexes is done only through easy linear algebra operations.  The most common operation is the sparse matrix-vector multiplication.Here a list of fundamental concepts and features of LAR: "
},

{
    "location": "lar.html#LAR-model-1",
    "page": "LAR",
    "title": "LAR model",
    "category": "section",
    "text": "A LAR model is a pair geometry, topology.  The geometry is specified by the position vectors of vertices in a Euclidean  space mathbbE^d of points with d coordinates. The topology is specified by one  or more bases of singleton k-chains (i.e.~k-cells) for 0 leq kleq d.  The vertex sharing between cells implicitly provides the attachment maps between  cells of various dimensions. Vertex positions are represented, by columns, by a  2-array of d real coordinates."
},

{
    "location": "lar.html#Chains-as-arrays-1",
    "page": "LAR",
    "title": "Chains as arrays",
    "category": "section",
    "text": "Chain-based modeling and computing~\\cite{DBLP:journals/corr/abs-0812-3249} is based  on representation of p-cell subsets as chains, elements of linear spaces C_p (0leq pleq d) generated by the space decomposition induced by a cellular complex, also said CW-complex. Chains can be simply represented as arrays of signed integers, one of simplest and more efficient data structure of most languages, particularly when oriented to scientific computing. Therefore, basic algebraic operations on chains as  vectors (sum and product times a scalar) are implemented over arrays."
},

{
    "location": "lar.html#Characteristic-matrices-1",
    "page": "LAR",
    "title": "Characteristic matrices",
    "category": "section",
    "text": "The LAR representation scheme~\\cite{Requicha:1980:RRS:356827.356833}, i.e. our  mapping between mathematical models of solids and their computer representations, uses linear chain spaces C_p as models, and sparse characteristic matrices M_p of p-cells as symbolic representations, where the p-cell sigma^kinLambda_p is represented as the k-th binary row of the sparse characteristic matrix M_p C_0to C_p."
},

{
    "location": "lar.html#Boundary-and-coboundary-matrices-1",
    "page": "LAR",
    "title": "Boundary and coboundary matrices",
    "category": "section",
    "text": "The boundary matrix partial_p is the matrix of the boundary operator  partial_p C_pto C_p-1 (1leq pleq d) that for each chain c_pin C_p  returns the boundary (p-1)-cycle of its (d-1)-faces. A boundary operator is linear:  partial_p c + d = partial_p c + partial_p d, for each cdin C_p. A cycle is a  chain without boundary. Hence, the boundary of a boundary is the zero map:  partial_p-1 circ partial_p = 0 (2leq pleq d)."
},

{
    "location": "lar.html#Incidence-matrices-1",
    "page": "LAR",
    "title": "Incidence matrices",
    "category": "section",
    "text": "Incidence operators between chain spaces of different dimension are easy to compute by matrix products of characteristic matrices (see Section \\ref{matrices}), possibly transposed. Since both characteristic and operator matrices are very sparse, their products are computed  with specialized algorithms for sparse matrices, whose complexity is roughly linear in the size  of the output sparse matrix, i.e., in the number of its stored non-zero elements. Incidence queries and other types of geometric or topological computations are not  performed element-wise, that necessarily require iterative or recursive programming patterns,  but only require matrix product times whole chains (sets of cells), so adapting naturally to parallel and/or dataflow computational patterns found in HPC and CNN architectures."
},

{
    "location": "lar.html#Validity-test-of-a-representation-1",
    "page": "LAR",
    "title": "Validity test of a representation",
    "category": "section",
    "text": "Data validity is easy to test by checking for satisfaction of basic equations  partialpartial=emptyset of a chain complex."
},

{
    "location": "lar.html#Space-arrangments-1",
    "page": "LAR",
    "title": "Space arrangments",
    "category": "section",
    "text": "Given a finite collection mathcalS of cellular complexes in mathbbE^d, d in 23, the \\emph{arrangement} mathcalA(mathcalS) is the decomposition of mathbbE^d into connected cells of dimensions 0 1 ldots d  induced by mathcalS. In LARLIB.jl, we provide an efficient computation of the arrangement produced by a given set of cellular complexes in either 2D or 3D.  The goal here is to provide a complete description of the plane or space decomposition  induced by the input, into cells of dimensions 0, 1, 2 or 3. This computation is based  on the algorithms introduced in \\cite{DBLP:journals/corr/PaoluzziSD17} which describe how  to compute the d-space arrangement generated by a collection of (d-1)-complexes.  A general description of both the motivations and the features of the space arrangement  and LARLIB.jl in general are given in~\\cite{DBLP:journals/corr/abs-1710-07819}.With abuse of language, we consider a finite cellular complex X as generated by a discrete  partition of an Euclidean space. In computing a cellular complex as the space arrangement of  a collection of geometric objects mathcalS, i.e. when  X = mathcalA(mathcalS),  we actually compute the whole chain complex C_bullet generated by X, i.e.:(Image: chains)where C_p (0geq pgeq 3) is a linear space of \\emph{p-chains} (subsets of p-cells  with algebraic structure). The linear operators partial_p and delta_p are the boundary  and coboundary operators as described before, respectively withpartial_p-1circpartial_p  = emptyset = delta_pcircdelta_p-1and where delta_p-1 = partial_p^top quad 1leq pleq 3"
},

{
    "location": "interface.html#",
    "page": "Interface",
    "title": "Interface",
    "category": "page",
    "text": ""
},

{
    "location": "interface.html#Interface-to-cell-and-chain-complexes-1",
    "page": "Interface",
    "title": "Interface to cell and chain complexes",
    "category": "section",
    "text": "Most part of text in this page is derived from  and from ."
},

{
    "location": "interface.html#Introduction-1",
    "page": "Interface",
    "title": "Introduction",
    "category": "section",
    "text": "With increased complexity of geometric data, topological models play an increasingly important role beyond boundary representations, assemblies, finite elements, image processing, and other traditional modeling applications. While many graph- and index- based data structures have been proposed, no standard representation has emerged as of now. Furthermore, such representations typically do not deal with representations of mappings and functions and do not scale to support parallel processing, open source, and client-based architectures. A proper mathematical model for all topological structures is a (co)chain complex: a sequence of linear (co)chain spaces and linear (co)boundary mappings. This in turn implies all topological structures may be represented by a collection of sparse matrices. We propose a Linear Algebraic Representation (LAR) scheme for mod 2 (co)chain complexes using CSC sparse matrices and show that it supports variety of topological computations using standard matrix algebra, without any overhead in space or running time. With the LAR scheme, only the characteristic functions (see below) of d-cells as vertex subsets are necessary for representing polytopal complexes. Examples include simplicial, cubical, and Voronoi complexes."
},

{
    "location": "interface.html#Data-structures-1",
    "page": "Interface",
    "title": "Data structures",
    "category": "section",
    "text": "All types of cell complexes and functions over cell complexes are properly represented by a (co)chain complex, that captures all combinatorial relationships of interest in solid and physical modeling formally and unambiguously. According to classical results from algebraic topology techniques, a (co)chain complex and all associated combinatorial operations are readily represented using standard techniques from linear algebra, giving rise to a Linear Algebraic Represention (LAR) scheme.In this package, we provide LAR data structures and algorithms using compressed sparse column (CSC) matrices, that introduce no computational overhead and are asymptotically as efficient as (and usually better than) many other popular topological data structures. Our aim is to provide a representation that supports all topological constructions and queries that arise in typical cellular decomposition of space (mesh, image, boundary, etc).An arrangement is the decomposition of d-dimensional space into connected and relatively open cells of lower dimensions, induced by an intersection of a finite collection of geometric objects. A planar collection S may include line segments, open or closed polygonal lines, polygons, two-dimensional meshes, and discrete images in 2D. A space collection may include 3D polygons, polygonal meshes, B-reps of solid models—either manifold or non-manifold, three-dimensional CAE meshes, and volumetric images in 3D.In this package, we have implemented the computation of the arrangement produced by a  set of cellular complexes in either 2D or 3D. Our goal is to provide a complete description of the plane or space decomposition induced by the input, into cells of dimensions 0, 1, 2 or 3."
},

{
    "location": "interface.html#Characteristic-matrices-1",
    "page": "Interface",
    "title": "Characteristic matrices",
    "category": "section",
    "text": "A precise mathematical definition of a cellular complex is not trivial; we may rely on the intuitive idea of constructing a space by gluing together a number of building blocks of different dimensions, called cells.The characteristic function chi_A  S to 0 1 is a function defined on a set S = s_j, that indicates membership of an element s_j in a subset A subseteq S, having the value 1 for all elements of A and the value 0 for all elements of S not in A. We call characteristic matrix M of a collection of subsets A_i subseteq S  (i=1n) the binary matrix M=(m_ij), with m_ij = chi_A_i(s_j)."
},

{
    "location": "interface.html#Examples-1",
    "page": "Interface",
    "title": "Examples",
    "category": "section",
    "text": "Binary matrix representing by rows the p-cells of a cellular complex. The input parameter must be of Cells type. Return a sparse binary matrix,  providing the basis of a Chain space of given dimension. Notice that the  number of columns is equal to the number of vertices (0-cells). First the cellular complex describing the 0-, 1-, 2-, anf 3-faces of a single unit cube is generated. V,(VV,EV,FV,CV) = cuboid([1.,1.,1.], true); Then, we may see the characteristic matrix of 1-cells (edges), with two ones per row:julia> full(characteristicMatrix(EV))\n12×8 Array{Int8,2}:\n 1  1  0  0  0  0  0  0\n 0  0  1  1  0  0  0  0\n 0  0  0  0  1  1  0  0\n 0  0  0  0  0  0  1  1\n 1  0  1  0  0  0  0  0\n 0  1  0  1  0  0  0  0\n 0  0  0  0  1  0  1  0\n 0  0  0  0  0  1  0  1\n 1  0  0  0  1  0  0  0\n 0  1  0  0  0  1  0  0\n 0  0  1  0  0  0  1  0\n 0  0  0  1  0  0  0  1and of 2-cells (faces):julia> full(characteristicMatrix(FV))\n6×8 Array{Int8,2}:\n 1  1  1  1  0  0  0  0\n 0  0  0  0  1  1  1  1\n 1  1  0  0  1  1  0  0\n 0  0  1  1  0  0  1  1\n 1  0  1  0  1  0  1  0\n 0  1  0  1  0  1  0  1Finally, the boundary of the single 3-cell contains all the 0-cells (vertices). Of course, the 3D cube has 12 edges in EV, 6 faces in FV, and one 3-cell in CV:julia> full(characteristicMatrix(CV))\n1×8 Array{Int8,2}:\n 1  1  1  1  1  1  1  1"
},

{
    "location": "interface.html#Chain-bases-1",
    "page": "Interface",
    "title": "Chain bases",
    "category": "section",
    "text": "In algebraic topology, a k-chain is a formal linear combination of the k-cells in a cell complex. In simplicial complexes (respectively, cubical complexes), k-chains are combinations of k-simplices (respectively, k-cubes).Let sigma be an oriented cell in X and mu in G. The elementary chain whose value is mu on sigma, -mu on -sigma and 0 on any other cell in X is denoted musigma . Each chain can then be written in a unique way as a sum of elementary chains. With abuse of notation, we do NOT distinguish between cells and singleton chains (i.e., the elementary chains whose value is 1sigma for some cell sigma), used as elements of the standard bases of chain groups.Chains are often thought of as attaching orientation and multiplicity to cells: if coefficients are extracted from the group G = (1 0 1 +)  (mathboldZ_3 +), then cells can only be discarded or selected, possibly inverting their orientation.  A p-cycle is a closed p-chain, i.e. a p-chain without boundary.  It is useful to select a conventional choice to orient the singleton chains (single cells) automatically. 0-cells are considered all positive. The p-cells, for 1  p  d-1, can be given an internal orientation according to the orientation of the first (p  1)-cell in their canonical representation, i.e. sorted on indices of their (p  1)-cycle. Finally, a d-cell may be oriented as the sign of its oriented volume."
},

{
    "location": "interface.html#Examples-2",
    "page": "Interface",
    "title": "Examples",
    "category": "section",
    "text": "A compact representation of bases of p-cells is provided by Cells type, defined as Array{Array{Int,1}}, where each element codifies a cell as the array of indices to vertices on the boundary of the cell:julia> V,(VV,EV,FV,CV) = LARLIB.cuboid([1.,1.,1.], true);\n\njulia> FV\n6-element Array{Array{Int64,1},1}:\n [1, 2, 3, 4]\n [5, 6, 7, 8]\n [1, 2, 5, 6]\n [3, 4, 7, 8]\n [1, 3, 5, 7]\n [2, 4, 6, 8]A simplicial decomposition of the unit cube with six 3-cells (tetrahedra), and a simplicial decomposition of the domain 05 times 01 with ten 2-cells (triangles) follows:julia> V,CV = LARLIB.simplexGrid([1,1,1]);\n\njulia> V\n3×8 Array{Float64,2}:\n 0.0  1.0  0.0  1.0  0.0  1.0  0.0  1.0\n 0.0  0.0  1.0  1.0  0.0  0.0  1.0  1.0\n 0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0\n\njulia> CV   # bases of tetrahedra\n6-element Array{Array{Int64,1},1}:\n [1, 2, 3, 5]\n [2, 3, 5, 6]\n [3, 5, 6, 7]\n [2, 3, 4, 6]\n [3, 4, 6, 7]\n [4, 6, 7, 8]\n\njulia> W,FW = LARLIB.simplexGrid([5,1]);\n\njulia> W\n2×12 Array{Float64,2}:\n 0.0  1.0  2.0  3.0  4.0  5.0  0.0  1.0  2.0  3.0  4.0  5.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0\n\njulia> FW   # bases of triangles\n10-element Array{Array{Int64,1},1}:\n [1, 2, 7]  \n [2, 7, 8]  \n [2, 3, 8]  \n [3, 8, 9]  \n [3, 4, 9]  \n [4, 9, 10] \n [4, 5, 10] \n [5, 10, 11]\n [5, 6, 11] \n [6, 11, 12]It is worthwhile to note that the above examples provide p-bases of suitable dimensions, equal to the number of p-cells,  for the corresponding chain complexes.   "
},

{
    "location": "interface.html#(Co)boundary-operators-1",
    "page": "Interface",
    "title": "(Co)boundary operators",
    "category": "section",
    "text": "Boundary operators are maps partial_p  C_p to C_p1 between chain spaces, i.e. between spaces of subsets of cells with different dimension, with 1 leq p leq d, hence for a cellular 2-complex we have two operators, denoted as partial_2  C_2 to C_1 and partial_1  C_1 to C_0, respectively. Since they are linear maps between linear spaces, may be represented by matrices of coefficients partial_2 and partial_1 from the corresponding groups. We use the groups 0 1and -1 0 1 for unsigned and signed coefficients, respectively.The concept of cochain  in a group C^p of linear maps from chains C_p to Re allows for the association of numbers not only to single cells, as done by chains, but also to assemblies of cells. A cochain is hence the association of every discretized subdomain (chain) of a cell complex with a numeric quantity, usually resulting from a discrete integration over a chain.Coboundary operators are maps delta^p  C^p to C^p+1, with each linear space  C^p of p-cochains isomorphic to the space C_p of p-chain. Therefore in this package only Chain spaces are used. Notice that partial_p = delta^p^t. This property is often utilized in our algorithms."
},

{
    "location": "interface.html#Examples-3",
    "page": "Interface",
    "title": "Examples",
    "category": "section",
    "text": "julia> V,(VV,EV,FV,CV) = cuboid([1.,1.,1.], true);\n\njulia> EV\n12-element Array{Array{Int64,1},1}:\n [1, 2]\n [3, 4]\n   ...\n [3, 7]\n [4, 8]\n\njulia> boundary_1( EV::Cells )\n8×12 SparseMatrixCSC{Int8,Int64} with 24 stored entries:\n  [1 ,  1]  =  -1\n  [2 ,  1]  =  1\n  [3 ,  2]  =  -1\n	...       ...\n  [7 , 11]  =  1\n  [4 , 12]  =  -1\n  [8 , 12]  =  1\n\njulia> full(boundary_1(EV::Cells))\n8×12 Array{Int8,2}:\n -1   0   0   0  -1   0   0   0  -1   0   0   0\n  1   0   0   0   0  -1   0   0   0  -1   0   0\n  0  -1   0   0   1   0   0   0   0   0  -1   0\n  0   1   0   0   0   1   0   0   0   0   0  -1\n  0   0  -1   0   0   0  -1   0   1   0   0   0\n  0   0   1   0   0   0   0  -1   0   1   0   0\n  0   0   0  -1   0   0   1   0   0   0   1   0\n  0   0   0   1   0   0   0   1   0   0   0   1Notice that the matrix partial_1,  generated by the function boundary_1 applied to the 1-cell basis EV, contains two non-zero elements per column, where the associated edge (1-cell) is oriented from the vertex (row) of lesser index, towards the vertex of greater index, according to our numbering convention."
},

{
    "location": "interface.html#Chain-complexes-1",
    "page": "Interface",
    "title": "Chain complexes",
    "category": "section",
    "text": "A chain complex, for our purposes, is an algebraic structure that consists of a sequence of linear spaces  and a sequence of linear maps between consecutive linear spaces,  such that the image of each map (subspace of boundaries of p-chains) is included in the kernel (subspace of cycles of (p-1)-chains) of the next. The set of all k-chains forms a group and the sequence of these groups is called a chain complex. In computing the arrangement A(S) induced by S, we actually compute the whole chain complex Cbullet generated by the cell complex X = A(S). For example, in 3D we compute all objects and arrows (morphisms) in the diagram below, and hence we obtain a computational knowledge of space subdivision homology, including the Euler number. "
},

{
    "location": "interface.html#Examples-4",
    "page": "Interface",
    "title": "Examples",
    "category": "section",
    "text": "From the minimal possible input, construct the whole two-dimensional chain complex, i.e. the bases for linear spaces C_1 and  C_2, of 1-chains and  2-chains, and the signed coboundary operators from  C_0 to C_1 and from C_1 to C_2."
},

{
    "location": "interface.html#D-Chain-complex-1",
    "page": "Interface",
    "title": "2D Chain complex",
    "category": "section",
    "text": "Start with the 1-skeleton (set of 1-cells) of a 2D small cuboidal grid (made of squares); in other words, suppose we only know the edges of the grid:julia> W = \n [0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  2.0  2.0  2.0  2.0  3.0  3.0  3.0  3.0\n  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0]\n# output  \n 2×16 Array{Float64,2}: ...\n\njulia> EW = \n[[1, 2],[2, 3],[3, 4],[5, 6],[6, 7],[7, 8],[9, 10],[10, 11],[11, 12],[13, 14],\n [14, 15],[15, 16],[1, 5],[2, 6],[3, 7],[4, 8],[5, 9],[6, 10],[7, 11],[8, 12],\n [9, 13],[10, 14],[11, 15],[12, 16]]\n# output  \n24-element Array{Array{Int64,1},1}: ...We go to compute the arrangement of the 2D space induced by the above, i.e. the full chain complex generated by (W,EW). This one is returned by the evaluation of the expression chaincomplex(W,EW). The output variable bases  will contain the meaningful cell bases, i.e. those of dimension 1 and 2, since dimension 0 – isolated 0-cells – is not so.julia> V,bases,coboundaries = chaincomplex(W,EW)\n\njulia> bases[1]	# edges\n24-element Array{Array{Int64,1},1}: ...\n\njulia> bases[2] # faces -- previously unknown !!\n9-element Array{Array{Int64,1},1}: ...Analogously, the coboundaries variable will contain the delta_1 and delta_2 matrices, of type SparseMatrixCSC{Int8,Int64}julia> coboundaries[1] # coboundary_1 \n24×16 SparseMatrixCSC{Int8,Int64} with 48 stored entries: ...\n\njulia> full(coboundaries[2]) # coboundary_1: faces as oriented 1-cycles of edges\n9×24 Array{Int8,2}:\n -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0  0  0\n  0 -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0  0\n  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0\n  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0\n  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0\n  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0\n  0  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1  0\n  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1  0  0\n  0  0  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1Note that the last matrix contains by rows the 2-cycles corresponding to the (previously) unknown 2-basis FV that can now be easily computed. Notice also that columns corresponding to interior edges (1-cells) contain two non-zeros of opposite sign. Hence the computed 2-complex is coherently oriented by the matrix rows, actually by construction. The 2-boundary operator matrix, i.e. transpose(coboundaries[2]), can be used to compute the boundary of every possible 2-chain, by matrix multiplication times the coordinate (binary) representation of the 2-chain, implemented by the type Chain, defined as SparseVector{Int8, Int}."
},

{
    "location": "interface.html#D-Chain-complex-2",
    "page": "Interface",
    "title": "3D Chain complex",
    "category": "section",
    "text": "The example discussed here concerns two unit cubes in 3D, where the second is partially rotated and translated, up to intersect only partially the firat cube. First we prepare our data, using a very simple hierarchical aggregation via a Struct object, to get a representation of faces and edges of both cubes in two Cells arrays FV and EV.julia> cube_1 = ([0 0 0 0 1 1 1 1; 0 0 1 1 0 0 1 1; 0 1 0 1 0 1 0 1], \n[[1,2,3,4],[5,6,7,8],[1,2,5,6],[3,4,7,8],[1,3,5,7],[2,4,6,8]], \n[[1,2],[3,4],[5,6],[7,8],[1,3],[2,4],[5,7],[6,8],[1,5],[2,6],[3,7],[4,8]] )\n\njulia> cube_2 = LARLIB.Struct([LARLIB.t(0,0,0.5), LARLIB.r(0,0,pi/3), cube_1])\n\njulia> V,FV,EV = LARLIB.struct2lar(LARLIB.Struct([ cube_1, cube_2 ]))Then we compute the 3D space arrangement induced by FV, providing the auxiliary information in EV, and getting back V,bases,coboundaries. Both bases and coboundaries are then disassembled into their component data structures. The actual discoveries computed by the arrangement algorithms, called by the chaincomplex function, are the NEW EV, FV, CV basis and the cscEV, cscFE, cscCF operators, which stands  for delta_0,delta_1, anddelta_2, i.e. the computations of the solid 3D cells generated by the arrangement of space, including their full topology.julia> V,bases,coboundaries = LARLIB.chaincomplex(V,FV,EV)\n\njulia> (EV, FV, CV), (cscEV, cscFE, cscCF) = bases,coboundaries\n\njulia> FV # bases[2]\n18-element Array{Array{Int64,1},1}:\n [1, 3, 4, 6]            \n [2, 3, 5, 6]            \n [7, 8, 9, 10]           \n [1, 2, 3, 7, 8]         \n [4, 6, 9, 10, 11, 12]   \n [5, 6, 11, 12]          \n [1, 4, 7, 9]            \n [2, 5, 11, 13]          \n [2, 8, 10, 11, 13]      \n [2, 3, 14, 15, 16]      \n [11, 12, 13, 17]        \n [11, 12, 13, 18, 19, 20]\n [2, 3, 13, 17]          \n [2, 13, 14, 18]         \n [15, 16, 19, 20]        \n [3, 6, 12, 15, 19]      \n [3, 6, 12, 17]          \n [14, 16, 18, 20]        \n\njulia> CV # bases[3]\n3-element Array{Array{Int64,1},1}:\n [2, 3, 5, 6, 11, 12, 13, 14, 15, 16, 18, 19, 20]\n [2, 3, 5, 6, 11, 12, 13, 17]                    \n [1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 17]    Let note that the LAR of FV includes faces with 5 and 6 vertices, even non convex.  Also, the CV variable contains the LAR of the three solid parts the two cubes are split into. julia> cscEV # coboundaries[1]\n34×20 SparseMatrixCSC{Int8,Int64} with 68 stored entries: ...\n\njulia> cscFE # coboundaries[2]\n18×34 SparseMatrixCSC{Int8,Int64} with 80 stored entries: ...\n\njulia> cscCF # coboundaries[3]\n4×18 SparseMatrixCSC{Int8,Int64} with 36 stored entries: ..."
},

{
    "location": "arrangement.html#",
    "page": "Arrangement",
    "title": "Arrangement",
    "category": "page",
    "text": ""
},

{
    "location": "arrangement.html#The-arrangement-algorithm-1",
    "page": "Arrangement",
    "title": "The arrangement algorithm",
    "category": "section",
    "text": "(Image: 10 x 10 Cube)Figure 1: Arrangement of 2000=2times10times10times10 cubes"
},

{
    "location": "arrangement.html#Theoretical-basis-1",
    "page": "Arrangement",
    "title": "Theoretical basis",
    "category": "section",
    "text": "The algorithm is based on the concept of recursive problem simplification  (a sort of divide et impera philosophy); if we have a d-complex, for every (d-1)-cell embedded into the mathbbE^d euclidean space, we bring the cell, and every other cell that could intersect it, down into mathbbE^d-1. We do this until we reach the d=1 in mathbbE^1 case; in here, we fragment all the 1-cells. Then, we travel back to the original d-dimension, and, for each dimensional step, we build correct complexes from cells provided by the  fragmentation of the lower dimension. (Image: Arrangement steps)Figure 2: Algorithm overviewWe have in input two cellular complexes [fig. 2, a],  given as 2-skeletons, which are the sets of 2-cells  [fig. 2, b, exploded]. Once we merged the skeletons,  we individuate for each 2-cell (that we will call sigma) all the other cells that could intersect it. We do this by computing the spatial index: it is a mapping mathcalI(sigma) from a cell  sigma to every other cell tau of which box(sigma) cap box(tau) neq emptyset, where the box function provides the axis aligned bounding box (AABB) of a cell [fig. 2, c,  sigma in red and mathcalI(sigma) in blue]. The spatial arrangement calculation is speeded up by storing the AABBs as dimensional wise intervals into an interval tree \\cite{interval_trees}.  Now for each cell sigma we transform sigma cup mathcalI(sigma)  in a way that sigma lays on the x_3=0 plane [fig. 2, d] and we find the intersections  of the mathcalI(sigma) cells with x_3=0 plane. So we have a \"soup\" of 1-cells in mathbbE^2 [fig. 2, e], and we fragment each 1-cell  with every other cell obtaining a valid 1-skeleton [fig. 2, f]. From this data it is possible to build the 2-cells using the ALGORITHM 1 presented and explored by Paoluzzi et al. \\cite{Paoluzzi} [fig. 2, g, exploded]. The procedure to fragment 1-cells on a plane and return a 2-complex is called planar arrangement. When the planar arrangement  is complete, fragmented sigma can be transformed back to its original position in mathbbE^3. With every 2-cell correctly fragmented, we can use the  already cited ALGORITHM 1 again to build a full 3-complex [fig. 2, h, exploded]. This is possible because ALGORITHM 1 is (almost) dimension independent."
},

{
    "location": "arrangement.html#The-\"1-cells-in-\\mathbb{E}2\"-base-case-1",
    "page": "Arrangement",
    "title": "The \"1-cells in mathbbE^2\" base case",
    "category": "section",
    "text": "(Image: Planar arrangement overview)Figure 3: Planar arrangement overviewThis is our base case. We have called planar arrangement the procedure to handle this case since it literally arranges a bunch of edges laying on a plane. So, in input there are 1-cells in mathbbE^2 and, optionally (but very likely), the boundary of the original 2-cell sigma  [fig. 3, a, sigma in red]. We consider each edge and we fragment it with every other edge. This brings to the creation of several coincident vertices: these will be eliminated using a KD-Tree [fig. 3, b, exploded].  At this point we have a perfectly fragmented 1-complex but many edges are superfluous and must be eliminated; two kind of edges are to discard: the ones outside the area of sigma and the ones which are not part of a maximal biconnected component  (We can talk about biconnected components because we can consider the 1-skeleton as a graph:  0-cells are nodes, 1-cells are edges and the boundary operator is a incidence matrix.). The result of this edge pruning outputs a 1-skeleton [fig. 3, c, exploded].After this, 2-cells must be computed: For each connected component we build a containment tree, which indicates which component is spatially inside an other component. Computing these relations lets us launch the ALGORITHM 1 \\cite{Paoluzzi} on each component and then combine the results to create 2-cells with non-intersecting  shells [fig. 3, d, 2-cells numbered in green; please note that cell 2 has cell 1 as an hole].note: Note\nA 2-cell with a non-intersecting shell can be trivially defined as a \"face with holes\"; the correct definition is that it cannot  be shrunk to the dimension of a point."
},

{
    "location": "arrangement.html#LARLIB.spatial_arrangement",
    "page": "Arrangement",
    "title": "LARLIB.spatial_arrangement",
    "category": "function",
    "text": "spatial_arrangement(V::Points, EV::ChainOp, FE::ChainOp; [multiproc::Bool])\n\nCompute the arrangement on the given cellular complex 2-skeleton in 3D.\n\nA cellular complex is arranged when the intersection of every possible pair of cell  of the complex is empty and the union of all the cells is the whole Euclidean space. The function returns the full arranged complex as a list of vertices V and a chain of borders EV, FE, CF.\n\nAdditional arguments:\n\nmultiproc::Bool: Runs the computation in parallel mode. Defaults to false.\n\n\n\n"
},

{
    "location": "arrangement.html#LARLIB.planar_arrangement",
    "page": "Arrangement",
    "title": "LARLIB.planar_arrangement",
    "category": "function",
    "text": "planar_arrangement(V::Points, EV::ChainOp, [sigma::Chain], [return_edge_map::Bool], [multiproc::Bool])\n\nCompute the arrangement on the given cellular complex 1-skeleton in 2D.\n\nA cellular complex is arranged when the intersection of every possible pair of cell  of the complex is empty and the union of all the cells is the whole Euclidean space. The basic method of the function without the sigma, return_edge_map and multiproc arguments  returns the full arranged complex V, EV and FE.\n\nAdditional arguments:\n\nsigma::Chain: if specified, planar_arrangement will delete from the output every edge and face outside this cell. Defaults to an empty cell.\nreturn_edge_map::Bool: makes the function return also an edge_map which maps the edges of the imput to the one of the output. Defaults to false.\nmultiproc::Bool: Runs the computation in parallel mode. Defaults to false.\n\n\n\n"
},

{
    "location": "arrangement.html#Main-Interface-1",
    "page": "Arrangement",
    "title": "Main Interface",
    "category": "section",
    "text": "LARLIB.spatial_arrangement\nLARLIB.planar_arrangement"
},

{
    "location": "mapper.html#",
    "page": "Mapper",
    "title": "Mapper",
    "category": "page",
    "text": ""
},

{
    "location": "mapper.html#Solid-primitives-by-domain-mapping-1",
    "page": "Mapper",
    "title": "Solid primitives by domain mapping",
    "category": "section",
    "text": "The mapper.jl file contains the implementation of several parametric primitives, including curves, surfaces and solids embedded in either 2D or 3D.The constructive approach is common to all methods. It consists in generating a simplicial or cuboidal decomposition of a simple geometrical domain in u,v or u,v,w parametric space. Then a change of coordinates, e.g. from Cartesian to polar or cylindrical coordinates, is applied to the vertices of the cellular complex decomposing the domain.(Image: )Figure 1: Cellular 3-complexes, slightly exploded: (a) cuboidal mesh; (b) simplicial mesh.So, the mapped domain produces a curved manifold in 2D or 3D space. To obtain a closed curved surface, i.e. a manifold-without-boundary, as in the case of a 2-sphere in 3D, or of the toroidal surface in 3D, a suitable identification of oincident mapped points is performed. "
},

{
    "location": "mapper.html#Basics-of-LAR-models-1",
    "page": "Mapper",
    "title": "Basics of LAR models",
    "category": "section",
    "text": "A very simple LAR model is a 2D square with a vertex on the origin: julia> square=([[0.; 0] [0; 1] [1; 0] [1; 1]], [[1,2,3,4]], [[1,2], [1,3], [2,4], [3,4]])\n([0.0 0.0 1.0 1.0; 0.0 1.0 0.0 1.0], Array{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2],\n[1, 3], [2, 4], [3, 4]])\nConvensional names for the arrays of vertice, faces and edges:julia> V,FV,EV = square\n([0.0 0.0 1.0 1.0; 0.0 1.0 0.0 1.0], Array{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2],\n[1, 3], [2, 4], [3, 4]])V may be either of type Array{Float64,2} or Array{Int64,2}julia> V::Points\n2×4 Array{Float64,2}:\n 0.0  0.0  1.0  1.0\n 0.0  1.0  0.0  1.0The arrays containing the p-dimensional (2leq pleq d) cells of a d-complex must be of type Array{Array{Int64,1},1}, where each element contains the unordered array of indices of vertices on the boundary of the cell:julia> EV\n4-element Array{Array{Int64,1},1}:\n [1, 2]\n [1, 3]\n [2, 4]\n [3, 4]"
},

{
    "location": "mapper.html#*Cuboidal*-and-*simplicial*-grids-1",
    "page": "Mapper",
    "title": "Cuboidal and simplicial grids",
    "category": "section",
    "text": "LARLIB, as its ancestor geometric language PLaSM and its father library pyplasm aims to be multidimensional. Hence some functions generate geometric models of varying dimensions. Important examples are cuboidGrid and simplexGrid, whose unique parameter is the shape of the generated mesh, i.e. the number of d-dimensional cells in each dimension, with d = length(shape). The vertices of the mesh stay on the integer grid of suitable dimension and size.julia> shape = [1,1,1]\n\njulia> cuboidGrid(shape)\n([0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 1.0 … 0.0 1.0], \nArray{Int64,1}[[1, 2, 3, 4, 5, 6, 7, 8]])Hence we have, for single-cell 1-, 2-, 3-, and 4-dimensional LAR models:julia> cuboidGrid([1])\n([0.0 1.0], Array{Int64,1}[[1, 2]])\n\njulia> cuboidGrid([1,1])\n([0.0 0.0 1.0 1.0; 0.0 1.0 0.0 1.0], Array{Int64,1}[[1, 2, 3, 4]])\n\njulia> cuboidGrid([1,1,1])\n([0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 1.0 … 0.0 1.0], \nArray{Int64,1}[[1, 2, 3, 4, 5, 6, 7, 8]])\n\njulia> cuboidGrid([1,1,1,1])\n([0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 1.0 … 0.0 1.0],\nArray{Int64,1}[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]])Two examples follows for a  20times 20  mesh in 2D, and a 20times 20times 20   mesh in 3D. Of course, their highest dimensional cells (quads and hexs) have 4 and 8 vertices, respectively.julia> cuboidGrid([20,20])\n([0.0 0.0 … 20.0 20.0; 0.0 1.0 … 19.0 20.0], Array{Int64,1}[[1, 2, 22, 23], [2, 3, 23,\n24], [3, 4, 24, 25], [4, 5, 25, 26], [5, 6, 26, 27], [6, 7, 27, 28], [7, 8, 28, 29], [8,\n9, 29, 30], [9, 10, 30, 31]  …  [415, 416, 436, 437], [416, 417, 437, 438], [417, 418,\n438, 439], [418, 419, 439, 440], [419, 420, 440, 441]])\n\njulia> cuboidGrid([20,20,20])\n([0.0 0.0 … 20.0 20.0; 0.0 0.0 … 20.0 20.0; 0.0 1.0 … 19.0 20.0], Array{Int64,1}[[1, 2,\n22, 23, 442, 443, 463, 464], [2, 3, 23, 24, 443, 444, 464, 465], [3, 4, 24, 25, 444, 445,\n465, 466]  …   [8797, 8798, 8818, 8819, 9238, 9239, 9259, 9260], [8798, 8799, 8819, 8820,\n9239, 9240, 9260, 9261]])(Image: )Figure 2: Cellular 3-complexes: (a) cuboidal mesh, with  0-, 1-, 2-, and 3-cells numbered with different colors; (b) exploded simplicial mesh, with 6 tetrahedra (3-cells) per mesh cube.Similarly, you can generate a multidimensional mesh of d-simplexs (d=123dots) with the simplexGrid function, having as single parameter the (cuboidal) shape of the mesh.Let us generate d (increasing in dimension) simplicial complexes partitioning a single hypercube 01^d:julia> simplexGrid([1]) # one segment in [0,1] \n# output\n([0.0 1.0], Array{Int64,1}[[1, 2]])\n\njulia> simplexGrid([1,1]) # two triangles in [0,1]^2 \n# output\n([0.0 1.0 0.0 1.0; 0.0 0.0 1.0 1.0], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])\n\njulia> simplexGrid([1,1,1])  # six tetrahedra in [0,1]^3 \n# output\n([0.0 1.0 … 0.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0], Array{Int64,1}[[1, 2, 3, 5],\n[2, 3, 5, 6], [3, 5, 6, 7], [2, 3, 4, 6], [3, 4, 6, 7], [4, 6, 7, 8]])\n\njulia> simplexGrid([1,1,1,1])  # 24 pentatopes in [0,1]^4 \n# output\n([0.0 1.0 … 0.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0],\nArray{Int64,1}[[1, 2, 3, 5, 9], [2, 3, 5, 9, 10], [3, 5, 9, 10, 11], [5, 9, 10, 11, 13],\n[2, 3, 5, 6, 10]  …  [4, 6, 7, 11, 12], [6, 7, 11, 12, 14], [7, 11, 12, 14, 15], [4, 6, 7,\n8, 12], [6, 7, 8, 12, 14], [7, 8, 12, 14, 15], [8, 12, 14, 15, 16]]) Then look at the simplicial partition (3D triangulation) of the domain 020times020times020 subset mathbfR^3 shown in Figure 1b, and generated by the Julia expression below:julia> simplexGrid([20,20,20]) \n# output\n([0.0 1.0 … 19.0 20.0; 0.0 0.0 … 20.0 20.0], Array{Int64,1}[[1, 2, 22], [2, 22, 23], [2,\n3, 23], [3, 23, 24], [3, 4, 24], [4, 24, 25], [4, 5, 25], [5, 25, 26], [5, 6, 26], [6, 26,\n27]  …  [415, 416, 436], [416, 436, 437], [416, 417, 437], [417, 437, 438], [417, 418,\n438], [418, 438, 439], [418, 419, 439], [419, 439, 440], [419, 420, 440], [420, 440,\n441]]) "
},

{
    "location": "mapper.html#List-of-currently-available-primitives-1",
    "page": "Mapper",
    "title": "List of currently available primitives",
    "category": "section",
    "text": "The mapper module aims to provide the tools needed to apply both dimension-independent affine transformations and general simplicial maps to geometric objects and assemblies developed within the LAR scheme. A large number of surfaces and primitives solids are definable using the map function and the local parametrizations."
},

{
    "location": "mapper.html#Curves-1",
    "page": "Mapper",
    "title": "Curves",
    "category": "section",
    "text": "Primitive one-dimensional objects:circle - Circle centered in the origin\nhelix - Helix curve about the z axis "
},

{
    "location": "mapper.html#Surfaces-1",
    "page": "Mapper",
    "title": "Surfaces",
    "category": "section",
    "text": "(Image: )Figure 3: Cellular 1- and 2-complexes: (a) 2D unit circle; (b) spiral curve embedded in 3D; (c) 2D unit disk; (3) spiraloid surface in 3D.Primitive two-dimensional objects:disk - Disk centered in the origin\nhelicoid - Helicoid about the z axis\nring - Ring centered in the origin\ncylinder - Cylinder surface with z axis\nsphere - Spherical surface of given radius\ntoroidal - Toroidal surface of given radiuses\ncrown - Half-toroidal surface of given radiuses(Image: )Figure 4: Cellular 2- and 3-complexes: (a) 2D disk; (b) cylinder surface in 3D; (c) 2-sphere surface in 3D; (3) toroidal surface in 3D."
},

{
    "location": "mapper.html#Solids-1",
    "page": "Mapper",
    "title": "Solids",
    "category": "section",
    "text": "Primitive three-dimensional objects:cuboid - Solid cuboid of given extreme vectors\nball - Solid Sphere of given radius\nrod - Solid cylinder of given radius and height\nhollowCyl - Hollow cylinder of given radiuses and height \nhollowBall - Hollow sphere of given radiuses\ntorus - Solid torus of given radiuses\npizza - Solid pizza of given radiuses(Image: )Figure 5: Cellular complexes: (a) 1-skeleton of 3D cube; (b) assembly of cell complexes of mixed dimensions; (c) 3-mesh of portion of hollow solid cylinder; (d) 3-mesh of a portion of hollow solid torus."
},

{
    "location": "mapper.html#Implementation-1",
    "page": "Mapper",
    "title": "Implementation",
    "category": "section",
    "text": "The coding of the generating functions for the various geometric primitives follows the below guidelines:*	 Higher level function interface. Every generating function is of type fun parms_1 to (parms_2 to results) with parms_1=p_1times p_2times cdots times p_m and parms_2=q_1times q_2times cdots times q_n. The p_i parameters concern the specification of the coordinate functions of the mapping. The q_j parameters (1leq jleq nin123)  affect the discretization of mapping domain.*	 Simplicial or cuboidal decomposition.  Discretization primitives simplexGrid() or cuboidGrid() are used for the two cases. Both primitives are dimension-independent, i.e. may decompose 1D, 2D, 3D,..., nD domains, depending only on the array shape of the generated cellular complex. The complex is generated in LAR format (vertices,cells), where vertices have integer coordinates. *	 Coordinate functions. Are applied to the integer vertices, so producing their mapped instances and store them in a Array{Array{Int64,1},1}*	Complex simplification. Finally, the geometrically coincident vertices are identified, the generated cells are translated to the new vertex indices, and cells are simplified from multiple identical indices. This may induce the sewing of domain boundaries according to expected topology of the curved manifold and/or the reduction of independent vertices in cells of the complex."
},

{
    "location": "mapper.html#Main-Interface-1",
    "page": "Mapper",
    "title": "Main Interface",
    "category": "section",
    "text": "LARLIB.mapper\nLARLIB.mapper"
},

{
    "location": "struct.html#",
    "page": "Assemblies",
    "title": "Assemblies",
    "category": "page",
    "text": ""
},

{
    "location": "struct.html#Assemblies-of-cellular-complexes-1",
    "page": "Assemblies",
    "title": "Assemblies of cellular complexes",
    "category": "section",
    "text": "Hierarchical models of complex assemblies are generated by aggregation of cellular complexes, each one defined in a local coordinate system, and possibly relocated by affine transformations of coordinates.  This operation may be repeated hierarchically, with subassemblies defined by aggregation of simpler parts, and so on, until to obtain a set of LAR models, which are not further decomposed.(Image: )Figure 1: Hierarchical assembly of cellular 3-complexes.Two main advantages can be found in a hierarchical modeling approach. Each component complex  and each assembly, at every hierarchical level, are defined independently from each other, using a local coordinate frame, suitably chosen to make its definition easier. Furthermore, only one copy of each component is stored in memory, and may be instanced in different locations and orientations how many times it is needed.(Image: )Figure 2: Hierarchical assembly of a 2-complex consisting of a single 2-cell (the square): (a) 2-skeleton; (b) 1-skeleton of the resulting complex."
},

{
    "location": "struct.html#Hierarchical-graphs-1",
    "page": "Assemblies",
    "title": "Hierarchical graphs",
    "category": "section",
    "text": "A hierarchical model, defined inductively as an assembly of component parts, is described by an acyclic directed multigraph, often called a scene graph or hierarchical structure in computer graphics and modeling.  The main algorithm with hierarchical assemblies is the traversal function, which transforms every component from local coordinates to global coordinates, called world coordinates."
},

{
    "location": "struct.html#Acyclic-directed-multigraph-1",
    "page": "Assemblies",
    "title": "Acyclic directed-multigraph",
    "category": "section",
    "text": "The standard definition of a directed graph G states that it is a pair (NA), where N is a set of nodes and A is a set of directed arcs, given as ordered pairs of nodes.  Such a definition is not sufficient when more than one arc must be considered between the same pair of nodes.In this case the notion of multigraph is introduced.  A directed multigraph is a triplet G = (NAf) where N and A are sets of nodes and arcs, respectively, and f A to mathbfN^2 is a mapping from arcs to node pairs.  In other words, in a multigraph, the same pair of nodes can be connected by multiple arcs.Directed graphs or multigraphs are said to be acyclic when they do not contain cycles, i.e. when no path starts and ends at the same vertex.  Trees are common examples of acyclic graphs. A tree, where each non-leaf node is the root of a subtree, is the best model of the concept of hierarchy. Nodes in a tree can be associated with their integer distance from the root, defined by the number of edges on the unique path from the root to the node.  A tree can be layered by levels, by putting in the same subset (level) all the nodes with equal distance from the root.  Acyclic graphs/multigraphs are also called hierarchical graphs, because they can be associated to a tree, generated at run-time by visiting the graph with some standard traversal algorithm, e.g. with a depth-first-search.  The ordered sequence of nodes produced by the traversal is sometimes called a linearized graph.  Each node in this sequence is suitably transformed from local coordinates to world coordinates, i.e. to the coordinates of the root, by the traversal algorithm."
},

{
    "location": "struct.html#Hierarchical-structures-1",
    "page": "Assemblies",
    "title": "Hierarchical structures",
    "category": "section",
    "text": "Various kinds of hierarchical assemblies are used in standard graphical systems, such as GKS, PHIGS and VRML, as well as in graphics libraries like Open Inventor and Java 3D.  The type of hierarchical structures adopted here is inspired, even in the name of the function used for this purpose, by the one introduced by PHIGS, i.e. Struct.The arcs of scene graphs are normally specified implicitly in real graphical systems. For example, an arc is actually specified when a node is contained or referred within another one. In particular, it is possible to specify a new container node together with either the matrix or the parameters of the transformation to be associated with the the arc that connects the new container to the current node."
},

{
    "location": "struct.html#Examples-1",
    "page": "Assemblies",
    "title": "Examples",
    "category": "section",
    "text": ""
},

{
    "location": "struct.html#Containers-of-geometric-objects-1",
    "page": "Assemblies",
    "title": "Containers of geometric objects",
    "category": "section",
    "text": "type Struct\n	body::Array\n	box\n	name::AbstractString\n	dim\n	category::AbstractString\nendwhere body::Array is the actual container, which may contain geometric models, affine transformations, and other structure values; box is a representation of the containment box; name is an identifier, initialized to the id of the empty object created by the constructor Struct(); dim is the dimension of the embedding space, i.e. the number of coordinates; category is a property of the created value, initializated to \"feature\".A typical LAR geometrical model is a Tuple (triple or pair), where the first element is the matrix of coordinates of vertices, and the remaining arrays of array of integers provide the vertex indices of each cell. julia> square = ([[0; 0] [0; 1] [1; 0] [1; 1]], [[1, 2, 3,\n4]], [[1,2], [1,3], [2,4], [3,4]])\n# output\n([0 0 1 1; 0 1 0 1], Array{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2], [1,\n3], [2, 4], [3, 4]]) A container of geometrical objects is defined by applying the function Struct to the array of contained objects.  The value returned from the application is a value of  Struct type.  The coordinate system of this value is the one associated with the first object of the Struct parameters.  Also, the resulting geometrical value is often associated with a variable name."
},

{
    "location": "struct.html#Affine-transformations-and-containers-1",
    "page": "Assemblies",
    "title": "Affine transformations and containers",
    "category": "section",
    "text": "Affine transformations or tensor matrices, of type Arra{Float64, 2}, are created by functionst(args...)	# for translation\ns(args...)	# for scaling\nr(args...)	# for rotationAn affine 3times 3 transformation matrix, generated in homogeneous normalized coordinates by the function call t(-0.5,-0.5), can be applied to a LAR object obj both explicitly by using the function apply(Matrix, obj) or implicitly by creating a Struct hierarchical object, as shown by the following examples:julia> table = apply( t(-0.5,-0.5), square )\n# output\n([-0.5 -0.5 0.5 0.5; -0.5 0.5 -0.5 0.5], Array{Int64,1}[[1, 2, 3, 4]],\nArray{Int64,1}[[1, 2], [1, 3], [2, 4], [3, 4]])\n\njulia> table = Struct([ t(-0.5,-0.5), square ])\n# output\nStruct(Any[[1.0 0.0 -0.5; 0.0 1.0 -0.5; 0.0 0.0 1.0], ([0 0 1 1; 0 1 0 1],\nArray{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2], [1, 3], [2, 4], [3, 4]])],\nArray[[-0.5; -0.5], [0.5; 0.5]], \"10234090646332247690\", 2, \"feature\") The generation of container nodes may continue hierarchically by suitably applying Struct. Notice that each LAR object in a Struct container is transformed by each matrix before it within the container, going from right to left. The action of a transformation (tensor) extends to each object on its right within its own container. Whereas,  the action of a tensor does not extend outside its container, according to the semantics of PHIGS structures.chair = Struct([ t(0.75,0), s(0.35,0.35), table ])"
},

{
    "location": "struct.html#Container-evaluation-1",
    "page": "Assemblies",
    "title": "Container evaluation",
    "category": "section",
    "text": "The function evalStruct, when applied to a Struct value, generates an Array of LAR models, each one originally defined  in a local coordinate system, transforming all of them in the same world coordinate, equal to the ones of the first object in the Struct parameter sequence.Conversely, the struct2lar function generates a single LAR model (cellular complex), whose components are here assigned respectively to variables W (coordinates of vertices), FW faces (2-cells), and EW edges (1-cells). Notice that the whole model is embedded in 2D, since the W array (coordinates by columns) has two rowsscene = evalStruct(struct02)	# array of LAR models\nW,FW,EW = struct2lar(struct02)	# single LAR model"
},

{
    "location": "struct.html#Simple-assembly-examples-1",
    "page": "Assemblies",
    "title": "Simple assembly examples",
    "category": "section",
    "text": "The object struct0 below contains a table and 4 chairs, struct01 is a row of 10 suitably translated instances of struct0, and struct02 is another assembly of suitably translated struct01 instances. struct0 = Struct([ t(2,1),table, repeat([r(pi/2), chair ], outer = 4)... ])\nstruct01 = Struct( repeat([ struct0, t(0,2.5) ], outer = 10) )\nscene = Struct( repeat([ struct01, t(3,0) ], outer = 10) )To see the generated 2D scene you need the LARVIEW module.using LARVIEW\nLARVIEW.view(scene)A different example provides a sphere, and a cylinder instance suitably translated, within the same Struct container. Of course, we could define a hierarchical assembly of any size and deep, containing any number of Struct nodes.assembly = Struct([sphere()(), t(3,0,-1), cylinder()()])\nusing LARVIEW\nLARVIEW.view(struct2lar(assembly))(Image: )Figure 3: (a) Enlargement of a portion of the exploded complex in Fig.1; (b) an assembly with two cuboidal 2-complexes (surfaces) embedded in 3D."
},

{
    "location": "struct.html#Coding-of-3D-refectory-assembly-1",
    "page": "Assemblies",
    "title": "Coding of 3D refectory assembly",
    "category": "section",
    "text": "The refectory model shown in Figure 1 is stepwise developed here. Of course, in order to display the various geometric models, the LARVIEW package is needed.using LARLIB\nL = LARLIB\n\nusing LARVIEW\nView = LARVIEW.view(Image: )Figure 4: The generation process of the refectory assembly shown in Figure 1.First develop the table model, starting from a single cube object, of type LAR = Tuple{Points,Cells}, suitably translated to get the base center at the origin, then create containers for tableTop, tablelegs, and table. Finally check the assembly correctness, and convert to a LAR value.  The View primitive may be applied both to  Struct and LAR values, as well to other types.cube = L.apply( L.t(-.5,-.5,0), L.cuboid([1,1,1]))\ntableTop = L.Struct([ L.t(0,0,.85), L.s(1,1,.05), cube ])\ntableLeg = L.Struct([ L.t(-.475,-.475,0), L.s(.1,.1,.89), cube ])\ntablelegs = L.Struct( repeat([ tableLeg, L.r(0,0,pi/2) ],outer=4) )\ntable = L.Struct([ tableTop, tablelegs ])\nView(table)\ntable = L.struct2lar(table)\nView(table)Then build the chair model as above. The polyhedral cylndr is defined with 8 lateral faces, and 16 vertices. cylndr = L.rod(.06, .5, 2*pi)([8,1])\nchairTop = L.Struct([ L.t(0,0,0.5), L.s(0.5,0.5,0.04), cube ])\nchairLeg = L.Struct([ L.t(-.22,-.22,0), L.s(.5,.5,1), L.r(0,0,pi/8), cylndr ])\nchairlegs = L.Struct( repeat([ chairLeg, L.r(0,0,pi/2) ],outer=4) );\nchair = L.Struct([ chairTop, chairlegs ]);\nchair = L.struct2lar(chair)\nView(chair)Just notice that, in expanding the chair data structure, 72 vertices and five 3-cells are obtained. If a model made of quads or triangles is needed, just generate cube and cylndr using different primitives in mapper.jl file.julia> chair[1]\n3×72 Array{Float64,2}:\n -0.25  -0.25  -0.25  -0.25   0.25   0.25  0.25  0.25  …  -0.247716  -0.231481  -0.231481\n -0.25  -0.25   0.25   0.25  -0.25  -0.25  0.25  0.25      0.208519   0.192284   0.192284\n  0.5    0.54   0.5    0.54   0.5    0.54  0.5   0.54      0.5        0.0        0.5     \njulia> chair[2]\n5-element Array{Array{Int64,1},1}:\n [1, 2, 3, 4, 5, 6, 7, 8]                                        \n [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24] \n [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40]\n [41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56]\n [57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72]Finally assemble the refectory model, by looping twice on a single coordinate.  Then a single LAR value is create, as well an Array{Any,1} collection of simplest LAR values, all given in Wold Coordinates.theChair = L.Struct([ L.t(-.8,0,0), chair ])\nfourChairs = L.Struct( repeat([L.r(0,0,pi/2), theChair],outer=4) );\nfourSit = L.Struct([fourChairs,table]);\nView(fourSit)\nsingleRow=L.Struct(repeat([fourSit,L.t(0,2.5,0)],outer=10));\nView(singleRow)\nrefectory=L.Struct(repeat([singleRow,L.t(3,0,0)],outer=10));\nView(refectory)"
},

{
    "location": "largrid.html#",
    "page": "Grids",
    "title": "Grids",
    "category": "page",
    "text": ""
},

{
    "location": "largrid.html#Generation-and-product-of-multidimensional-complexes-1",
    "page": "Grids",
    "title": "Generation and product of multidimensional complexes",
    "category": "section",
    "text": "We introduce the use of multidimensional grid generation of cuboidal and simplicial cell complexes, and the more general Cartesian product of cellular complexes. Both kind of operators, depending on the dimension of their input, may generate either full-dimensional (i.e. solid) output complexes, or lower-dimensional complexes of dimension d embedded in Euclidean space of dimension n, with dleq n.  E.g., just think to a mesh of 3D cubes in three-dimensional space for the first case, and to the (non-manifold) framework of boundary polygons of such cubic cells for the second case. In particular,  both n-dimensional solid grids of (hyper)-cuboidal cells and their  d-dimensional skeletons (0leq dleq n), embedded in E^n, are generated by assembling the cells produced by a number n of either 0- or 1-dimensional cell complexes, that in such lowest dimensions coincide with simplicial complexes. "
},

{
    "location": "largrid.html#Introduction-1",
    "page": "Grids",
    "title": "Introduction",
    "category": "section",
    "text": "First the simple implementation of lower-dimensional (say, either 0- or 1-dimensional) regular cellular complexes with integer coordinates is built. Then, the generation of either full-dimensional cuboidal complexes in E^n and  their d-skeletons (0leq dleq n) is provided, since every skeleton can be efficiently generated as a partition of cell subsets produced by the Cartesian product of a proper ordered combination of 0-1 complexes, according to the binary representation of a subset of the integer interval 02^n. For this purpose a simple and general implementation of topological product of two cellular complexes of any topology is given by the package. When applied to cellular complexes (i.e. when the coordinates of 0-cells of arguments are fixed and given) the algorithm produces a Cartesian product of its arguments."
},

{
    "location": "largrid.html#The-base-case-1",
    "page": "Grids",
    "title": "The base case",
    "category": "section",
    "text": "We use 0- and 1-dimensional cell complexes as the basic material for several operations, including generation of simplicial and cellular grids and topological and Cartesian product of cell complexes.  The grid_0 second-order function generates a 0-dimensional uniform complex embedding n+1 equally-spaced (at unit intervals) 0-cells within the 0n interval. It returns the cells of this 0-complex, as an array of indices to vertices. The grid_1 second-order function generates a 1-dimensional uniform complex embedding n  1-cells of unit size within the 0n interval. A larGrid function is given to generate the LAR representation of the cells of either a 0- or a 1-dimensional complex, depending on the value of a d parameter, to take values in the set 01, and providing the order of the output complex.julia> larGrid(10)(0)\n1×11 Array{Int64,2}:\n 0  1  2  3  4  5  6  7  8  9  10\n\njulia> larGrid(10)(1)\n2×10 Array{Int64,2}:\n 0  1  2  3  4  5  6  7  8   9\n 1  2  3  4  5  6  7  8  9  10"
},

{
    "location": "largrid.html#Dimension-independent-cuboidal-grids-1",
    "page": "Grids",
    "title": "Dimension-independent cuboidal grids",
    "category": "section",
    "text": "More interesting is the generation of hyper-cubical grids of intrinsic dimension d embedded in n-dimensional space, via the Cartesian product of d 1-complexes and (n-d) 0-complexes. When d=n the resulting grid is said solid; when d=0 the output grid is 0-dimensional, and corresponds to a grid-arrangement of a discrete set of points in E^n.Generation of grid cells by Cartesian product of 0/1-complexes. The output complex is generated by the product of any number of either 0- or 1-dimensional cell complexes. The product of d 1-complexes generates solid d-cells, while the product of n 0-complexes and n-d 1-complexes (d  n) generates non-solid (n-d)-cells, properly embedded in n-space, i.e. with vertices having n coordinates.The second-order utility index2addr function transforms a multidimensional shape array into a function that, when applied to a multindex array, i.e. to a list of integers within the shape\'s bounds, returns the integer address of the array component, within the linear storage of the multidimensional array.The transformation formula for a d-dimensional array with shape (n_0n_1n_d-1) is a linear combination of the 0-based multi-index (i_0i_1i_d-1) with weights equal to (w_0w_1w_d-21):addr = i_0times w_0 +i_1times w_1 +cdots +i_d-1times w_d-1where w_k = n_k+1 times n_k+2 timescdotstimes  n_d-1 qquad 0leq kleq d-2Therefore, we get index2addr([4,3,6])([2,2,0])=48=2times(3times 6)+2times(6times 1)+0, where [2,2,0] represent the numbers of (pages, rows, columns) indexing an element in the three-dimensional array of shape [4,3,6]."
},

{
    "location": "largrid.html#Examples-1",
    "page": "Grids",
    "title": "Examples",
    "category": "section",
    "text": "To understand the generation of cuboidal grids from products of 0- or 1-dimensional complexes, below we show a simple example of 2D grids embedded in R^3. In particular, v1 = [0 1 2 3] and v0 = [0 1 2] are two 2-arrays of 1D Points (i.e. with just one coordinate per vertex), c1 = [[0,1],[1,2],[2,3]] and c0 = [[0],[1],[2]] are the LAR representation of one 1-complex and one 0-complex, respectively. The solid 2-complex named grid2D is generated in 2D as follows, with reference to LARLIB types:julia> v1 = [0 1 2 3]::LARLIB.Points\n1×4 Array{Int64,2}:\n 0  1  2  3\n\njulia> c1 = [[0,1],[1,2],[2,3]]::LARLIB.Cells\n3-element Array{Array{Int64,1},1}:\n [0, 1]\n [1, 2]\n [2, 3]\n\njulia> grid2D = ( LARLIB.larVertProd([v1,v1]), LARLIB.larCellProd([c1,c1]) )::LARLIB.LAR\n([0 0 … 3 3; 0 1 … 2 3], Array{Int64,1}[[1, 2, 5, 6], [2, 3, 6, 7], [3, 4, 7, 8], [5, 6,\n9, 10], [6, 7, 10, 11], [7, 8, 11, 12], [9, 10, 13, 14], [10, 11, 14, 15], [11, 12, 15,\n16]])\n\njulia> grid2D[1]\n2×16 Array{Int64,2}:\n 0  0  0  0  1  1  1  1  2  2  2  2  3  3  3  3\n 0  1  2  3  0  1  2  3  0  1  2  3  0  1  2  3\n\njulia> grid2D[2]\n9-element Array{Array{Int64,1},1}:\n [1, 2, 5, 6]    \n [2, 3, 6, 7]    \n [3, 4, 7, 8]    \n [5, 6, 9, 10]   \n [6, 7, 10, 11]  \n [7, 8, 11, 12]  \n [9, 10, 13, 14] \n [10, 11, 14, 15]\n [11, 12, 15, 16]\n"
},

{
    "location": "largrid.html#Main-Interface-1",
    "page": "Grids",
    "title": "Main Interface",
    "category": "section",
    "text": "LARLIB.largrid"
},

{
    "location": "glossary.html#",
    "page": "Glossary",
    "title": "Glossary",
    "category": "page",
    "text": ""
},

{
    "location": "glossary.html#Glossary-1",
    "page": "Glossary",
    "title": "Glossary",
    "category": "section",
    "text": ""
},

{
    "location": "glossary.html#Cells-1",
    "page": "Glossary",
    "title": "Cells",
    "category": "section",
    "text": "To do."
},

{
    "location": "glossary.html#Cell-1",
    "page": "Glossary",
    "title": "Cell",
    "category": "section",
    "text": "To do."
},

{
    "location": "glossary.html#Chain-of-borders-1",
    "page": "Glossary",
    "title": "Chain of borders",
    "category": "section",
    "text": "To do."
},

{
    "location": "glossary.html#LarCells-1",
    "page": "Glossary",
    "title": "LarCells",
    "category": "section",
    "text": "To do."
},

{
    "location": "glossary.html#Points-1",
    "page": "Glossary",
    "title": "Points",
    "category": "section",
    "text": "To do."
},

]}
