var documenterSearchIndex = {"docs": [

{
    "location": "index.html#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": ""
},

{
    "location": "index.html#LARLIB.jl-1",
    "page": "Home",
    "title": "LARLIB.jl",
    "category": "section",
    "text": ""
},

{
    "location": "index.html#Dependencies-1",
    "page": "Home",
    "title": "Dependencies",
    "category": "section",
    "text": "LARLIB.jl has several Julia dependencies:NearestNeighbors\nDataStructures\nIntervalTrees\nTRIANGLE"
},

{
    "location": "index.html#Docstrings-conventions-1",
    "page": "Home",
    "title": "Docstrings conventions",
    "category": "section",
    "text": "Bold is used to point out theory concepts. For example, look at the  \"2-skeletons\" word in the docstring of LARLIB.skel_merge:LARLIB.skel_merge(V1::LARLIB.Verts, EV1::LARLIB.Cells, V2::LARLIB.Verts, EV2::LARLIB.Cells)Monospace is used for everything code related. Look this time at \"container\", \"contained\" and \"Verts\" in the docstring of LARLIB.bbox_contains:LARLIB.bbox_containsnote: Note\nIn Julia REPL the monospace text is the one colored differently. In a terminal you will see something like:   (Image: Julia REPL monospace exaple)"
},

{
    "location": "lar.html#",
    "page": "LAR",
    "title": "LAR",
    "category": "page",
    "text": ""
},

{
    "location": "lar.html#LAR-1",
    "page": "LAR",
    "title": "LAR",
    "category": "section",
    "text": "LAR is a general representation scheme for geometric and topological modeling~\\cite{Dicarlo:2014:TNL:2543138.2543294}.  The domain of the scheme is provided by cellular complexes while its codomain is a set of sparse matrices. The main advantages of the scheme are:It is extremely effective to easily represent general non-manifold solids.  For example, the memory representation of a d=3 cellular complex using LAR consists in only two binary sparse matrices for the topology and a bi-dimensional array for the geometry.\nComputation and analysis of cellular complexes is done only through easy linear algebra operations.  The most common operation is the sparse matrix-vector multiplication.Here a list of fundamental concepts and features of LAR: "
},

{
    "location": "lar.html#LAR-model-1",
    "page": "LAR",
    "title": "LAR model",
    "category": "section",
    "text": "A LAR model is a pair geometry, topology.  The geometry is specified by the position vectors of vertices in a Euclidean  space mathbbE^d of points with d coordinates. The topology is specified by one  or more bases of singleton k-chains (i.e.~k-cells) for 0 leq kleq d.  The vertex sharing between cells implicitly provides the attachment maps between  cells of various dimensions. Vertex positions are represented, by columns, by a  2-array of d real coordinates."
},

{
    "location": "lar.html#Chains-as-arrays-1",
    "page": "LAR",
    "title": "Chains as arrays",
    "category": "section",
    "text": "Chain-based modeling and computing~\\cite{DBLP:journals/corr/abs-0812-3249} is based  on representation of p-cell subsets as chains, elements of linear spaces C_p (0leq pleq d) generated by the space decomposition induced by a cellular complex, also said CW-complex. Chains can be simply represented as arrays of signed integers, one of simplest and more efficient data structure of most languages, particularly when oriented to scientific computing. Therefore, basic algebraic operations on chains as  vectors (sum and product times a scalar) are implemented over arrays."
},

{
    "location": "lar.html#Characteristic-matrices-1",
    "page": "LAR",
    "title": "Characteristic matrices",
    "category": "section",
    "text": "The LAR representation scheme~\\cite{Requicha:1980:RRS:356827.356833}, i.e. our  mapping between mathematical models of solids and their computer representations, uses linear chain spaces C_p as models, and sparse characteristic matrices M_p of p-cells as symbolic representations, where the p-cell sigma^kinLambda_p is represented as the k-th binary row of the sparse characteristic matrix M_p C_0to C_p."
},

{
    "location": "lar.html#Boundary-and-coboundary-matrices-1",
    "page": "LAR",
    "title": "Boundary and coboundary matrices",
    "category": "section",
    "text": "The boundary matrix partial_p is the matrix of the boundary operator  partial_p C_pto C_p-1 (1leq pleq d) that for each chain c_pin C_p  returns the boundary (p-1)-cycle of its (d-1)-faces. A boundary operator is linear:  partial_p c + d = partial_p c + partial_p d, for each cdin C_p. A cycle is a  chain without boundary. Hence, the boundary of a boundary is the zero map:  partial_p-1 circ partial_p = 0 (2leq pleq d)."
},

{
    "location": "lar.html#Incidence-matrices-1",
    "page": "LAR",
    "title": "Incidence matrices",
    "category": "section",
    "text": "Incidence operators between chain spaces of different dimension are easy to compute by matrix products of characteristic matrices (see Section \\ref{matrices}), possibly transposed. Since both characteristic and operator matrices are very sparse, their products are computed  with specialized algorithms for sparse matrices, whose complexity is roughly linear in the size  of the output sparse matrix, i.e., in the number of its stored non-zero elements. Incidence queries and other types of geometric or topological computations are not  performed element-wise, that necessarily require iterative or recursive programming patterns,  but only require matrix product times whole chains (sets of cells), so adapting naturally to parallel and/or dataflow computational patterns found in HPC and CNN architectures."
},

{
    "location": "lar.html#Validity-test-of-a-representation-1",
    "page": "LAR",
    "title": "Validity test of a representation",
    "category": "section",
    "text": "Data validity is easy to test by checking for satisfaction of basic equations  partialpartial=emptyset of a chain complex."
},

{
    "location": "lar.html#Space-arrangments-1",
    "page": "LAR",
    "title": "Space arrangments",
    "category": "section",
    "text": "Given a finite collection mathcalS of cellular complexes in mathbbE^d, d in 23, the \\emph{arrangement} mathcalA(mathcalS) is the decomposition of mathbbE^d into connected cells of dimensions 0 1 ldots d  induced by mathcalS. In LARLIB.jl, we provide an efficient computation of the arrangement produced by a given set of cellular complexes in either 2D or 3D.  The goal here is to provide a complete description of the plane or space decomposition  induced by the input, into cells of dimensions 0, 1, 2 or 3. This computation is based  on the algorithms introduced in \\cite{DBLP:journals/corr/PaoluzziSD17} which describe how  to compute the d-space arrangement generated by a collection of (d-1)-complexes.  A general description of both the motivations and the features of the space arrangement  and LARLIB.jl in general are given in~\\cite{DBLP:journals/corr/abs-1710-07819}.With abuse of language, we consider a finite cellular complex X as generated by a discrete  partition of an Euclidean space. In computing a cellular complex as the space arrangement of  a collection of geometric objects mathcalS, i.e. when  X = mathcalA(mathcalS),  we actually compute the whole chain complex C_bullet generated by X, i.e.:(Image: chains)where C_p (0geq pgeq 3) is a linear space of \\emph{p-chains} (subsets of p-cells  with algebraic structure). The linear operators partial_p and delta_p are the boundary  and coboundary operators as described before, respectively withpartial_p-1circpartial_p  = emptyset = delta_pcircdelta_p-1and where delta_p-1 = partial_p^top quad 1leq pleq 3"
},

{
    "location": "arrangement.html#",
    "page": "Arrangement",
    "title": "Arrangement",
    "category": "page",
    "text": ""
},

{
    "location": "arrangement.html#The-arrangement-algorithm-1",
    "page": "Arrangement",
    "title": "The arrangement algorithm",
    "category": "section",
    "text": "(Image: 10 x 10 Cube)Figure 1: Arrangement of 2000=2times10times10times10 cubes"
},

{
    "location": "arrangement.html#Theoretical-basis-1",
    "page": "Arrangement",
    "title": "Theoretical basis",
    "category": "section",
    "text": "The algorithm is based on the concept of recursive problem simplification  (a sort of divide et impera philosophy); if we have a d-complex, for every (d-1)-cell embedded into the mathbbE^d euclidean space, we bring the cell, and every other cell that could intersect it, down into mathbbE^d-1. We do this until we reach the d=1 in mathbbE^1 case; in here, we fragment all the 1-cells. Then, we travel back to the original d-dimension, and, for each dimensional step, we build correct complexes from cells provided by the  fragmentation of the lower dimension. (Image: Arrangement steps)Figure 2: Algorithm overviewWe have in input two cellular complexes [fig. 2, a],  given as 2-skeletons, which are the sets of 2-cells  [fig. 2, b, exploded]. Once we merged the skeletons,  we individuate for each 2-cell (that we will call sigma) all the other cells that could intersect it. We do this by computing the spatial index: it is a mapping mathcalI(sigma) from a cell  sigma to every other cell tau of which box(sigma) cap box(tau) neq emptyset, where the box function provides the axis aligned bounding box (AABB) of a cell [fig. 2, c,  sigma in red and mathcalI(sigma) in blue]. The spatial arrangement calculation is speeded up by storing the AABBs as dimensional wise intervals into an interval tree \\cite{interval_trees}.  Now for each cell sigma we transform sigma cup mathcalI(sigma)  in a way that sigma lays on the x_3=0 plane [fig. 2, d] and we find the intersections  of the mathcalI(sigma) cells with x_3=0 plane. So we have a \"soup\" of 1-cells in mathbbE^2 [fig. 2, e], and we fragment each 1-cell  with every other cell obtaining a valid 1-skeleton [fig. 2, f]. From this data it is possible to build the 2-cells using the ALGORITHM 1 presented and explored by Paoluzzi et al. \\cite{Paoluzzi} [fig. 2, g, exploded]. The procedure to fragment 1-cells on a plane and return a 2-complex is called planar arrangement. When the planar arrangement  is complete, fragmented sigma can be transformed back to its original position in mathbbE^3. With every 2-cell correctly fragmented, we can use the  already cited ALGORITHM 1 again to build a full 3-complex [fig. 2, h, exploded]. This is possible because ALGORITHM 1 is (almost) dimension independent."
},

{
    "location": "arrangement.html#The-\"1-cells-in-\\mathbb{E}2\"-base-case-1",
    "page": "Arrangement",
    "title": "The \"1-cells in mathbbE^2\" base case",
    "category": "section",
    "text": "(Image: Planar arrangement overview)Figure 3: Planar arrangement overviewThis is our base case. We have called planar arrangement the procedure to handle this case since it literally arranges a bunch of edges laying on a plane. So, in input there are 1-cells in mathbbE^2 and, optionally (but very likely), the boundary of the original 2-cell sigma  [fig. 3, a, sigma in red]. We consider each edge and we fragment it with every other edge. This brings to the creation of several coincident vertices: these will be eliminated using a KD-Tree [fig. 3, b, exploded].  At this point we have a perfectly fragmented 1-complex but many edges are superfluous and must be eliminated; two kind of edges are to discard: the ones outside the area of sigma and the ones which are not part of a maximal biconnected component  (We can talk about biconnected components because we can consider the 1-skeleton as a graph:  0-cells are nodes, 1-cells are edges and the boundary operator is a incidence matrix.). The result of this edge pruning outputs a 1-skeleton [fig. 3, c, exploded].After this, 2-cells must be computed: For each connected component we build a containment tree, which indicates which component is spatially inside an other component. Computing these relations lets us launch the ALGORITHM 1 \\cite{Paoluzzi} on each component and then combine the results to create 2-cells with non-intersecting  shells [fig. 3, d, 2-cells numbered in green; please note that cell 2 has cell 1 as an hole].note: Note\nA 2-cell with a non-intersecting shell can be trivially defined as a \"face with holes\"; the correct definition is that it cannot  be shrunk to the dimension of a point."
},

{
    "location": "arrangement.html#Main-Interface-1",
    "page": "Arrangement",
    "title": "Main Interface",
    "category": "section",
    "text": "LARLIB.spatial_arrangement\nLARLIB.planar_arrangement"
},

{
    "location": "mapper.html#",
    "page": "Mapper",
    "title": "Mapper",
    "category": "page",
    "text": ""
},

{
    "location": "mapper.html#Solid-primitives-by-domain-mapping-1",
    "page": "Mapper",
    "title": "Solid primitives by domain mapping",
    "category": "section",
    "text": "The mapper.jl file contains the implementation of several parametric primitives, including curves, surfaces and solids embedded in either 2D or 3D.The constructive approach is common to all methods. It consists in generating a simplicial or cuboidal decomposition of a simple geometrical domain in u,v or u,v,w parametric space. Then a change of coordinates, e.g. from Cartesian to polar or cylindrical coordinates, is applied to the vertices of the cellular complex decomposing the domain.(Image: )Figure 1: Cellular 3-complexes, slightly exploded: (a) cuboidal mesh; (b) simplicial mesh.So, the mapped domain produces a curved manifold in 2D or 3D space. To obtain a closed curved surface, i.e. a manifold-without-boundary, as in the case of a 2-sphere in 3D, or of the toroidal surface in 3D, a suitable identification of oincident mapped points is performed. "
},

{
    "location": "mapper.html#Basics-of-LAR-models-1",
    "page": "Mapper",
    "title": "Basics of LAR models",
    "category": "section",
    "text": "A very simple LAR model is a 2D square with a vertex on the origin: julia> square=([[0.; 0] [0; 1] [1; 0] [1; 1]], [[1,2,3,4]], [[1,2], [1,3], [2,4], [3,4]])\n([0.0 0.0 1.0 1.0; 0.0 1.0 0.0 1.0], Array{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2],\n[1, 3], [2, 4], [3, 4]])\nConvensional names for the arrays of vertice, faces and edges:julia> V,FV,EV = square\n([0.0 0.0 1.0 1.0; 0.0 1.0 0.0 1.0], Array{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2],\n[1, 3], [2, 4], [3, 4]])V may be either of type Array{Float64,2} or Array{Int64,2}julia> V::Verts\n2×4 Array{Float64,2}:\n 0.0  0.0  1.0  1.0\n 0.0  1.0  0.0  1.0The arrays containing the p-dimensional (2leq pleq d) cells of a d-complex must be of type Array{Array{Int64,1},1}, where each element contains the unordered array of indices of vertices on the boundary of the cell:julia> EV\n4-element Array{Array{Int64,1},1}:\n [1, 2]\n [1, 3]\n [2, 4]\n [3, 4]"
},

{
    "location": "mapper.html#*Cuboidal*-and-*simplicial*-grids-1",
    "page": "Mapper",
    "title": "Cuboidal and simplicial grids",
    "category": "section",
    "text": "LARLIB, as its ancestor geometric language PLaSM and its father library pyplasm aims to be multidimensional. Hence some functions generate geometric models of varying dimensions. Important examples are cuboidGrid and simplexGrid, whose unique parameter is the shape of the generated mesh, i.e. the number of d-dimensional cells in each dimension, with d = length(shape). The vertices of the mesh stay on the integer grid of suitable dimension and size.julia> shape = [1,1,1]\n\njulia> cuboidGrid(shape)\n([0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 1.0 … 0.0 1.0], \nArray{Int64,1}[[1, 2, 3, 4, 5, 6, 7, 8]])Hence we have, for single-cell 1-, 2-, 3-, and 4-dimensional LAR models:julia> cuboidGrid([1])\n([0.0 1.0], Array{Int64,1}[[1, 2]])\n\njulia> cuboidGrid([1,1])\n([0.0 0.0 1.0 1.0; 0.0 1.0 0.0 1.0], Array{Int64,1}[[1, 2, 3, 4]])\n\njulia> cuboidGrid([1,1,1])\n([0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 1.0 … 0.0 1.0], \nArray{Int64,1}[[1, 2, 3, 4, 5, 6, 7, 8]])\n\njulia> cuboidGrid([1,1,1,1])\n([0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 1.0 … 0.0 1.0],\nArray{Int64,1}[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]])Two examples follows for a  20times 20  mesh in 2D, and a 20times 20times 20   mesh in 3D. Of course, their highest dimensional cells (quads and hexs) have 4 and 8 vertices, respectively.julia> cuboidGrid([20,20])\n([0.0 0.0 … 20.0 20.0; 0.0 1.0 … 19.0 20.0], Array{Int64,1}[[1, 2, 22, 23], [2, 3, 23,\n24], [3, 4, 24, 25], [4, 5, 25, 26], [5, 6, 26, 27], [6, 7, 27, 28], [7, 8, 28, 29], [8,\n9, 29, 30], [9, 10, 30, 31]  …  [415, 416, 436, 437], [416, 417, 437, 438], [417, 418,\n438, 439], [418, 419, 439, 440], [419, 420, 440, 441]])\n\njulia> cuboidGrid([20,20,20])\n([0.0 0.0 … 20.0 20.0; 0.0 0.0 … 20.0 20.0; 0.0 1.0 … 19.0 20.0], Array{Int64,1}[[1, 2,\n22, 23, 442, 443, 463, 464], [2, 3, 23, 24, 443, 444, 464, 465], [3, 4, 24, 25, 444, 445,\n465, 466]  …   [8797, 8798, 8818, 8819, 9238, 9239, 9259, 9260], [8798, 8799, 8819, 8820,\n9239, 9240, 9260, 9261]])(Image: )Figure 2: Cellular 3-complexes: (a) cuboidal mesh, with  0-, 1-, 2-, and 3-cells numbered with different colors; (b) exploded simplicial mesh, with 6 tetrahedra (3-cells) per mesh cube.Similarly, you can generate a multidimensional mesh of d-simplexs (d=123dots) with the simplexGrid function, having as single parameter the (cuboidal) shape of the mesh.Let us generate d (increasing in dimension) simplicial complexes partitioning a single hypercube 01^d:julia> simplexGrid([1]) # one segment in [0,1] \n# output\n([0.0 1.0], Array{Int64,1}[[1, 2]])\n\njulia> simplexGrid([1,1]) # two triangles in [0,1]^2 \n# output\n([0.0 1.0 0.0 1.0; 0.0 0.0 1.0 1.0], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])\n\njulia> simplexGrid([1,1,1])  # six tetrahedra in [0,1]^3 \n# output\n([0.0 1.0 … 0.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0], Array{Int64,1}[[1, 2, 3, 5],\n[2, 3, 5, 6], [3, 5, 6, 7], [2, 3, 4, 6], [3, 4, 6, 7], [4, 6, 7, 8]])\n\njulia> simplexGrid([1,1,1,1])  # 24 pentatopes in [0,1]^4 \n# output\n([0.0 1.0 … 0.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0],\nArray{Int64,1}[[1, 2, 3, 5, 9], [2, 3, 5, 9, 10], [3, 5, 9, 10, 11], [5, 9, 10, 11, 13],\n[2, 3, 5, 6, 10]  …  [4, 6, 7, 11, 12], [6, 7, 11, 12, 14], [7, 11, 12, 14, 15], [4, 6, 7,\n8, 12], [6, 7, 8, 12, 14], [7, 8, 12, 14, 15], [8, 12, 14, 15, 16]]) Then look at the simplicial partition (3D triangulation) of the domain 020times020times020 subset mathbfR^3 shown in Figure 1b, and generated by the Julia expression below:julia> simplexGrid([20,20,20]) \n# output\n([0.0 1.0 … 19.0 20.0; 0.0 0.0 … 20.0 20.0], Array{Int64,1}[[1, 2, 22], [2, 22, 23], [2,\n3, 23], [3, 23, 24], [3, 4, 24], [4, 24, 25], [4, 5, 25], [5, 25, 26], [5, 6, 26], [6, 26,\n27]  …  [415, 416, 436], [416, 436, 437], [416, 417, 437], [417, 437, 438], [417, 418,\n438], [418, 438, 439], [418, 419, 439], [419, 439, 440], [419, 420, 440], [420, 440,\n441]]) "
},

{
    "location": "mapper.html#List-of-currently-available-primitives-1",
    "page": "Mapper",
    "title": "List of currently available primitives",
    "category": "section",
    "text": "The mapper module aims to provide the tools needed to apply both dimension-independent affine transformations and general simplicial maps to geometric objects and assemblies developed within the LAR scheme. A large number of surfaces and primitives solids are definable using the map function and the local parametrizations."
},

{
    "location": "mapper.html#Curves-1",
    "page": "Mapper",
    "title": "Curves",
    "category": "section",
    "text": "Primitive one-dimensional objects:circle - Circle centered in the origin\nhelix - Helix curve about the z axis "
},

{
    "location": "mapper.html#Surfaces-1",
    "page": "Mapper",
    "title": "Surfaces",
    "category": "section",
    "text": "(Image: )Figure 3: Cellular 1- and 2-complexes: (a) 2D unit circle; (b) spiral curve embedded in 3D; (c) 2D unit disk; (3) spiraloid surface in 3D.Primitive two-dimensional objects:disk - Disk centered in the origin\nhelicoid - Helicoid about the z axis\nring - Ring centered in the origin\ncylinder - Cylinder surface with z axis\nsphere - Spherical surface of given radius\ntoroidal - Toroidal surface of given radiuses\ncrown - Half-toroidal surface of given radiuses(Image: )Figure 4: Cellular 2- and 3-complexes: (a) 2D disk; (b) cylinder surface in 3D; (c) 2-sphere surface in 3D; (3) toroidal surface in 3D."
},

{
    "location": "mapper.html#Solids-1",
    "page": "Mapper",
    "title": "Solids",
    "category": "section",
    "text": "Primitive three-dimensional objects:cuboid - Solid cuboid of given extreme vectors\nball - Solid Sphere of given radius\nrod - Solid cylinder of given radius and height\nhollowCyl - Hollow cylinder of given radiuses and height \nhollowBall - Hollow sphere of given radiuses\ntorus - Solid torus of given radiuses\npizza - Solid pizza of given radiuses(Image: )Figure 5: Cellular complexes: (a) 1-skeleton of 3D cube; (b) assembly of cell complexes of mixed dimensions; (c) 3-mesh of portion of hollow solid cylinder; (d) 3-mesh of a portion of hollow solid torus."
},

{
    "location": "mapper.html#Implementation-1",
    "page": "Mapper",
    "title": "Implementation",
    "category": "section",
    "text": "The coding of the generating functions for the various geometric primitives follows the below guidelines:*	 Higher level function interface. Every generating function is of type fun parms_1 to (parms_2 to results) with parms_1=p_1times p_2times cdots times p_m and parms_2=q_1times q_2times cdots times q_n. The p_i parameters concern the specification of the coordinate functions of the mapping. The q_j parameters (1leq jleq nin123)  affect the discretization of mapping domain.*	 Simplicial or cuboidal decomposition.  Discretization primitives simplexGrid() or cuboidGrid() are used for the two cases. Both primitives are dimension-independent, i.e. may decompose 1D, 2D, 3D,..., nD domains, depending only on the array shape of the generated cellular complex. The complex is generated in LAR format (vertices,cells), where vertices have integer coordinates. *	 Coordinate functions. Are applied to the integer vertices, so producing their mapped instances and store them in a Array{Array{Int64,1},1}*	Complex simplification. Finally, the geometrically coincident vertices are identified, the generated cells are translated to the new vertex indices, and cells are simplified from multiple identical indices. This may induce the sewing of domain boundaries according to expected topology of the curved manifold and/or the reduction of independent vertices in cells of the complex."
},

{
    "location": "mapper.html#Main-Interface-1",
    "page": "Mapper",
    "title": "Main Interface",
    "category": "section",
    "text": "LARLIB.mapper\nLARLIB.mapper"
},

{
    "location": "struct.html#",
    "page": "Assemblies",
    "title": "Assemblies",
    "category": "page",
    "text": ""
},

{
    "location": "struct.html#Assemblies-of-cellular-complexes-1",
    "page": "Assemblies",
    "title": "Assemblies of cellular complexes",
    "category": "section",
    "text": "Hierarchical models of complex assemblies are generated by aggregation of cellular complexes, each one defined in a local coordinate system, and possibly relocated by affine transformations of coordinates.  This operation may be repeated hierarchically, with subassemblies defined by aggregation of simpler parts, and so on, until to obtain a set of LAR models, which are not further decomposed.Two main advantages can be found in a hierarchical modeling approach. Each component complex  and each assembly, at every hierarchical level, are defined independently from each other, using a local coordinate frame, suitably chosen to make its definition easier. Furthermore, only one copy of each component is stored in memory, and may be instanced in different locations and orientations how many times it is needed.(Image: )Figure 1: Hierarchical assembly of a complex consisting of a single 2-cell (the square): (a) 2-skeleton; (b) 1-skeleton of the resulting complex."
},

{
    "location": "struct.html#Hierarchical-graphs-1",
    "page": "Assemblies",
    "title": "Hierarchical graphs",
    "category": "section",
    "text": "A hierarchical model, defined inductively as an assembly of component parts, is described by an acyclic directed multigraph, often called a scene graph or hierarchical structure in computer graphics and modeling.  The main algorithm with hierarchical assemblies is the traversal function, which transforms every component from local coordinates to global coordinates, called world coordinates."
},

{
    "location": "struct.html#Acyclic-directed-multigraph-1",
    "page": "Assemblies",
    "title": "Acyclic directed-multigraph",
    "category": "section",
    "text": "The standard definition of a directed graph G states that it is a pair (NA), where N is a set of nodes and A is a set of directed arcs, given as ordered pairs of nodes.  Such a definition is not sufficient when more than one arc must be considered between the same pair of nodes.In this case the notion of multigraph is introduced.  A directed multigraph is a triplet G = (NAf) where N and A are sets of nodes and arcs, respectively, and f A to mathbfN^2 is a mapping from arcs to node pairs.  In other words, in a multigraph, the same pair of nodes can be connected by multiple arcs.Directed graphs or multigraphs are said to be acyclic when they do not contain cycles, i.e. when no path starts and ends at the same vertex.  Trees are common examples of acyclic graphs. A tree, where each non-leaf node is the root of a subtree, is the best model of the concept of hierarchy. Nodes in a tree can be associated with their integer distance from the root, defined by the number of edges on the unique path from the root to the node.  A tree can be layered by levels, by putting in the same subset (level) all the nodes with equal distance from the root.  Acyclic graphs/multigraphs are also called hierarchical graphs, because they can be associated to a tree, generated at run-time by visiting the graph with some standard traversal algorithm, e.g. with a depth-first-search.  The ordered sequence of nodes produced by the traversal is sometimes called a linearized graph.  Each node in this sequence is suitably transformed from local coordinates to world coordinates, i.e. to the coordinates of the root, by the traversal algorithm."
},

{
    "location": "struct.html#Hierarchical-structures-1",
    "page": "Assemblies",
    "title": "Hierarchical structures",
    "category": "section",
    "text": "Various kinds of hierarchical assemblies are used in standard graphical systems, such as GKS, PHIGS and VRML, as well as in graphics libraries like Open Inventor and Java 3D.  The type of hierarchical structures adopted here is inspired, even in the name of the function used for this purpose, by the one introduced by PHIGS, i.e. Struct.The arcs of scene graphs are normally specified implicitly in real graphical systems. For example, an arc is actually specified when a node is contained or referred within another one. In particular, it is possible to specify a new container node together with either the matrix or the parameters of the transformation to be associated with the the arc that connects the new container to the current node."
},

{
    "location": "struct.html#Examples-1",
    "page": "Assemblies",
    "title": "Examples",
    "category": "section",
    "text": "A typical LAR geometrical model is a Tuple (triple or pair), where the first element is the matrix of coordinates of vertices, and the remaining arrays of array of integers provide the vertex indices of each cell. julia> square = ([[0; 0] [0; 1] [1; 0] [1; 1]], [[1, 2, 3,\n4]], [[1,2], [1,3], [2,4], [3,4]])\n# output\n([0 0 1 1; 0 1 0 1], Array{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2], [1,\n3], [2, 4], [3, 4]]) A container of geometrical objects is defined by applying the function Struct to the array of contained objects.  The value returned from the application is a value of  Struct type.  The coordinate system of this value is the one associated with the first object of the Struct parameters.  Also, the resulting geometrical value is often associated with a variable name.An affine 3times 3 transformation matrix, generated in homogeneous normalized coordinates by the function t(-0.5,-0.5), can be applied to a LAR object obj both explicitly, by using the higher function applytoMatrixtoobj, or implicitly by creating a Struct hierarchical object, as shown by the following examples:julia> table = apply( t(-0.5,-0.5) )( square )\n# output\n([-0.5 -0.5 0.5 0.5; -0.5 0.5 -0.5 0.5], Array{Int64,1}[[1, 2, 3, 4]],\nArray{Int64,1}[[1, 2], [1, 3], [2, 4], [3, 4]])\n\njulia> table = Struct([ t(-0.5,-0.5), square ])\n# output\nStruct(Any[[1.0 0.0 -0.5; 0.0 1.0 -0.5; 0.0 0.0 1.0], ([0 0 1 1; 0 1 0 1],\nArray{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2], [1, 3], [2, 4], [3, 4]])],\nArray[[-0.5; -0.5], [0.5; 0.5]], \"10234090646332247690\", 2, \"feature\") The generation of container nodes may continue hierarchically by suitably applying Struct. Notice that each LAR object in a Struct container is transformed by each matrix before it within the container, going from right to left. The action of a transformation (tensor) extends to each object on its right within its own container. Whereas,  the action of a tensor does not extend outside its container, according to the semantics of PHIGS structures.chair = Struct([ t(0.75,0), s(0.35,0.35), table ])The object struct0 below contains a table and 4 chairs, struct01 is a row of 10 suitably translated instances of struct0, and struct02 is another assembly of suitably translated struct01 instances. struct0 = Struct([ t(2,1),table, repeat([r(pi/2), chair ], outer = 4)... ])\nstruct01 = Struct( repeat([ struct0, t(0,2.5) ], outer = 10) )\nstruct02 = Struct( repeat([ struct01, t(3,0) ], outer = 10) )The function evalStruct generates an Array of LAR models, each one originally defined  in a local coordinate system, transforming all of them in the same world coordinate, equal to the ones of the first object in the Struct parameter sequence.Conversely, the struct2lar function generates a single LAR model (cellular complex), whose components are here assigned respectively to variables W (coordinates of vertices), FW faces (2-cells), and EW edges (1-cells). Notice that the whole model is embedded in 2D, since the W array (coordinates by columns) has two rowsscene = evalStruct(struct02)	# array of LAR models\nW,FW,EW = struct2lar(struct02)	# single LAR modelAnyway, the larView function, which instances a pyplasm viewer, can be applied both to an array of models and to a single model. The examples below intend to show either the 2-cells or the 1-cells of the generated cellular complex, respectively.using LARVIEW\nlarView(scene)\nlarView(W,EW)A different example provides a sphere, and a cylinder instance suitably translated, within the same Struct container. Of course, we could define a hierarchical assembly of any size and deep, containing any number of Struct nodes.assembly = Struct([sphere()(), t(3,0,-1), cylinder()()])\nusing LARVIEW\nlarView(struct2lar(assembly))(Image: )Figure 2: (a) Enlargement of a portion of the exploded complex in Fig.1; (b) an assembly with two cuboidal 2-complexes (surfaces) embedded in 3D."
},

{
    "location": "glossary.html#",
    "page": "Glossary",
    "title": "Glossary",
    "category": "page",
    "text": ""
},

{
    "location": "glossary.html#Glossary-1",
    "page": "Glossary",
    "title": "Glossary",
    "category": "section",
    "text": ""
},

{
    "location": "glossary.html#Cells-1",
    "page": "Glossary",
    "title": "Cells",
    "category": "section",
    "text": "To do."
},

{
    "location": "glossary.html#Cell-1",
    "page": "Glossary",
    "title": "Cell",
    "category": "section",
    "text": "To do."
},

{
    "location": "glossary.html#Chain-of-borders-1",
    "page": "Glossary",
    "title": "Chain of borders",
    "category": "section",
    "text": "To do."
},

{
    "location": "glossary.html#LarCells-1",
    "page": "Glossary",
    "title": "LarCells",
    "category": "section",
    "text": "To do."
},

{
    "location": "glossary.html#Verts-1",
    "page": "Glossary",
    "title": "Verts",
    "category": "section",
    "text": "To do."
},

]}
